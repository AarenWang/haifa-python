# jq 支持阶段性设计方案

## 背景
当前 `compiler` 子模块提供类汇编→AST→字节码→寄存器虚拟机 的完整流水线，运行时仅支持整数与简单数组操作。目标是在现有 VM 基础上实现与 `jq` 类似的 JSON 过滤能力，为项目提供更强的数据处理场景支持。

## 总体目标
- 扩展 VM 数据模型，使其能原生承载 JSON 值（对象、数组、字符串、数字、布尔、null）。
- 在虚拟机流水线中实现 `jq` 过滤语义（管道、多结果输出、字段访问、迭代、内建函数等）。
- 提供命令行入口，与标准输入/输出对接，兼容常见 `jq` 用法。
- 保持现有类汇编指令集与测试可运行，避免破坏现有功能。

## 分层架构（自里程碑 5/6 起）
- Core VM（bytecode_vm）只承载通用指令；
- JQ VM（jq_vm）作为工具层入口，承载/注册 jq 专属处理器；
- 编译器（jq_compiler）对接 JQ VM，后续逐步将 jq-only 指令从 Core 迁出。

## 非目标
- 不追求 100% 覆盖 `jq` 全部语法/函数，重点围绕常用子集。
- 暂不实现即时编译、并行执行、流式增量 JSON 解析等高级特性。

## 当前架构痛点
1. **类型限制**：`ExecutionContext.val` 与 `BytecodeVM.val` 会将字面量强制转换为整数，数组实现为 `List[int]`，无法保存复杂 JSON。
2. **指令语义不足**：指令集围绕算术与控制流，不具备对象/数组遍历、生成器式输出等能力。
3. **缺少 `jq` 前端**：解析器仅支持行式汇编脚本，不理解 `jq` 表达式。
4. **缺少 CLI 管线**：无统一的命令行入口读取 JSON / 输出结果。

## 分阶段路线图

### 阶段 1：JSON 值基础能力
- **数据抽象**
  - 新增 `JsonValue` 包装（或直接使用 Python 原生类型）并在执行上下文、寄存器、数组存储中应用。
  - 为寄存器引入统一 `ValueSlot`（字典/类），支持字符串/布尔/null。
  - 更新 `ExecutionContext.val` 与 VM 对应方法，区分立即数（字面量）与寄存器引用。
- **指令集调整**
  - 允许 `MOV` 等指令操作非整数值。
  - 更新数组指令以支持通用 JSON 数组。
- **兼容保障**
  - 确保现有算术指令在需要时执行类型检查或显式转换。
- **测试计划**
  - 扩展单元测试覆盖字符串/布尔/null 的寄存器操作与数组读写。
  - 保持现有测试通过。

### 阶段 2：最小可用 `jq` 子集
- **表达式解析器**
  - 定义 `jq` AST 节点（Identity、Field, Literal, ArrayIter, Pipe 等）。
  - 编写递归下降解析器，支持语法：`.`、`.foo`、`.[]`、字符串/数字字面量、简单函数调用（`length`）与管道 `|`。
  - 解析结果既可直接解释，也可映射为类汇编脚本。
- **AST → VM 映射**
  - 约定 VM 寄存器语义：`$in`（当前输入）、`$curr`（当前值）、`$tmpN`（临时值）。
  - 为对象访问/数组迭代新增指令：`OBJ_GET dst src key`、`ITER_ARRAY src dst_body_label dst_end_label`（或通过现有跳转模板展开）。
  - 管道阶段编译为顺序代码块，每个阶段以 `PUSH_RESULT`/`EMIT` 指令驱动输出缓存。
- **运行时机制**
  - 在 VM 侧维护 `current_values` 队列，实现多输出流；`PRINT_JSON` 指令负责序列化。
  - CLI 接口初期仅处理单个 JSON 输入；保留 `--slurp`/`--raw-output` 设计占位。
- **测试计划**
  - 针对解析器：`.foo`, `.items[]`, `.items[] | .name`, `length` 等用例结构化断言。
  - 针对 VM：编译后的脚本运行比对预期 JSON 输出（需构造 fixture JSON）。
  - CLI：模拟标准输入/输出完成端到端测试。

**已完成进展快照**
- VM 新增 `EMIT`/`PUSH_EMIT`/`POP_EMIT` 指令实现通用多结果流，jq 编译器支持 `map(...)`、`select(...)` 常见过滤器。
- 提供 `python -m compiler.jq_cli` CLI，可读取 stdin 或文件并输出 JSON 行结果，配套单元/集成测试覆盖。

2025-09-23（Milestone 1 完成）
- 解析器支持运算符与优先级：`+ - * / %`、`== != > >= < <=`、`and or not`、`//`（coalesce），含括号分组。
- 新增 AST：`UnaryOp`、`BinaryOp`；编译器完成到现有字节码的映射（`!=`/`>=`/`<=` 以组合指令实现）。
- `//` 编译为空值合并（左值非 null 则取左，否则取右）。
- VM `JZ` 采用统一真值语义（Python falsy 即跳转），兼容既有用例；保留 `DIV` 为整除以通过既有测试。
- 新增解析/运行时用例，全部测试通过（70 passed）。

2025-09-23（Milestone 2 完成）
- 支持索引与切片：`.foo[0]`、`.[-1]`、`.[i:j]`、`.[ :j]`、`.[i: ]`，负索引归一化且边界截断。
- 编译为 `GET_INDEX` + 循环收集；切片结果作为数组值。

2025-09-23（Milestone 3 完成）
- 核心集合过滤器：`keys`, `has`, `contains`, `add`, `join`, `reverse`, `first`, `last`, `any`, `all`。
- 新增 VM 指令或模板展开，覆盖对象/数组/字符串的常见语义；稳定等值判定。

2025-09-23（Milestone 4 完成）
- 排序与聚合家族：`sort`, `sort_by(expr)`, `min/max`, `min_by/max_by`, `unique/unique_by`, `group_by(expr)`。
- 采用（keys, values）配对策略与健壮排序键，保证混合类型下的稳定排序与分组。

2025-09-23（Milestone 5 完成）
- 变量与绑定：语法支持 `$var` 与 `expr as $x`，变量在编译期映射到固定寄存器 `__jq_var_<name>`。
- CLI 互操作：`--arg/--argjson` 变量注入，`-n/--null-input`，`-R/--raw-input`，`--slurp` 输入模式，`-r/--raw-output`，`-c/--compact-output` 输出模式，`-f/--filter-file` 读取过滤器文件。
- 测试覆盖：变量绑定链式管道、raw/compact 输出、null-input 与 raw-input、filter 文件等端到端用例。

### 阶段 3：扩展特性与优化
- **更多过滤器**
  - 实现 `map`, `select`, `reduce` 等高频函数。
  - 支持比较、逻辑、算术在 JSON 值上的推广。
- **错误与诊断**
  - 改进错误提示：语法错误、类型错误。
  - CLI 增加 `--debug` 输出，便于调试。
- **性能与内存**
  - 引入懒执行或迭代器优化，避免大数组复制。
  - 评估缓存策略（如字段访问路径编译）。
- **文档与示例**
  - 输出用户指南、示例脚本。
- **测试计划**
  - 增加复杂场景测试、压力用例。

## 风险与对策
- **类型系统复杂度提升**：逐步引入类型封装并保持接口一致，配套测试保障。
- **解析器实现成本**：先聚焦核心语法，采用递归下降+操作符优先级方案；必要时引入第三方库但需评估许可。
- **多结果输出语义**：从阶段 2 起引入统一迭代器接口，缩小后续变更范围。

## 近期行动项（起始迭代）
1. 调整执行上下文与 VM 寄存器模型，支持存储任意 JSON 值。
2. 更新基础指令测试，验证字符串/布尔/null 读写正确。
3. 设计 `jq` 解析输出的 AST/字节码结构草稿，为阶段 2 做准备。
